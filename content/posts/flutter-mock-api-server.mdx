---
title: Mocking API's using embedded web server inside flutter apps
date: 2021-05-03
---

Say you are working on an app ui. But required APIs are not ready. Yet you need to deliver the app UI implementation as complete as possible anyways. You could;

- Hardcode API responses into app code
- Use something like [mockito](https://pub.dev/packages/mockito) and work with tests
- Create a web server app and run it separately.
- Embed a web server inside flutter app itself.

I ended up taking the last option, skip to it below if rest of them seem obvious. Each option has their pros and cons so;

## Hardcoding API responses

### Pros
- Easy.
- App UI behaves as expected.
- Everything can be done in same codebase.
- No need to have a server running.

### Cons
- Code is not final
- Difficult to test http errors
- Difficult to test race conditions
- Difficult to test serialization / deserialization

## Developing with mocks / stubs in tests

### Pros
- Means that you write tests, nice.
- Ability to test http errors
- Ability to test serialization / deserialization
- Mocks are in same codebase with app.

### Cons
- Doesn't work in end user UI.
- End users can't test with it.
- Need to run the tests to work with them.
- Need to write and setup tests (not too bad anyways)

## Create a web server app and run it separately

### Pros
- Having an actual web server close as it gets to real API implementation
- Ability to test everything related to http and REST
- Ability to test http errors
- Ability to test JSON serialization / deserialization

### Cons
- Need to create the web server as a separate project.
- Say if you made it in nodejs, need to run it separately.
- Need to figure out how to get the correct port relayed to the emulator
- What if port and uri changes, how does the app know
- Distributed release app will need to talk to the web server so server needs to be up and running all the time somewhere.

None of these options seemed to be covering everything we needed so. We had this idea;

## Put the web server into the app
This is not too different than any app having an embedded web server in it. What this means is to have a web server process spawned when app launces, then serves mock endpoints on localhost:3169 (whatever port you want really) Then you app talks to itself to fetch from the mock api.

This could ofcourse be achieved in multiple ways also. You could embed any web server via a native module, similarly in react-native too.

This was particulary simple to do using flutter. Being able to useboth same process and same language and codebase made it easy to make and extend.

- Server restarts when you hot-restart the flutter app
- What port will be serving is in your code so your api client knows which port to listen from.
- Re-use data models made for dart.
- Same json encoding/decoding approach with the actual app code.

When you compare this with other options above;

### Pros
- Server in the same app
- Same language and project
- Easy to develop
- Lots of shared code

### Cons
- Maybe the port would clash with something (but you can change the port)

Implementation of this is based on flutter's own HTTP server. Using a convenience wrapper around it with [shelf](https://pub.dev/packages/shelf) package. And for making intercepting requests more declaratively similar to express / sinatra / flash -ish way, used [shelf_router](https://pub.dev/packages/shelf_router) package.

So here's how the server code looks like;

```dart
import 'dart:convert';

import 'package:logging/logging.dart';
import 'package:shelf/shelf.dart';
import 'package:shelf/shelf_io.dart' as shelf_io;
import 'package:shelf_router/shelf_router.dart' as shelf_router;

Logger log = Logger('LocalMockApiServer');

class LocalMockApiServer {
  static final host = 'localhost';
  static final port = 3131;
  static get baseUrl => 'http://$host:$port/';

  late shelf_router.Router app;

  LocalMockApiServer() {
    app = shelf_router.Router();

    app.get('/user/account', (Request req) async {
      return JsonMockResponse.ok({
        'id': req.accessToken,
      });
    });

    app.get('/user/investments', (Request req) async {
      return JsonMockResponse.ok([
        {
          'key': 'value',
        },
        {
          'key': 'value',
        },
      ], delay: 1200);
    });
  }

  Future<void> start() async {
    log.info('starting...');

    var handler = const Pipeline().addMiddleware(
      logRequests(logger: (message, isError) {
        if (isError)
          log.severe(message);
        else
          log.info(message);
      }),
    ).addHandler(app);

    var server = await shelf_io.serve(handler, host, port);
    server.autoCompress = true;

    log.info('serving on: $baseUrl');
  }
}

extension on Request {
  Future<String?> bodyJsonValue(String param) async {
    return jsonDecode(await this.readAsString())?[param];
  }

  String? get accessToken =>
      this.headers['Authorization']?.split('Bearer ').last;
}

extension JsonMockResponse on Response {
  static ok<T>(T json, {int delay = 800}) async {
    await Future.delayed(Duration(milliseconds: delay)); // Emulate lag
    return Response.ok(
      jsonEncode(json),
      headers: {'Content-Type': 'application/json'},
    );
  }
}
```

Let's break this down and see what is happening;


Gist of it is that we make create class called `LocalMockApiServer` which sets up the server, and has a async `start` method. I removed some implementation details from below for brevity, complete class implementation is above.

```dart
class LocalMockApiServer {
  static final host = 'localhost';
  static final port = 3131;
  static get baseUrl => 'http://$host:$port/';

  late shelf_router.Router app;

  LocalMockApiServer() {
    app = shelf_router.Router();

    //  1: Request handler here
    //  2: Request handler here
  }

  Future<void> start() async {
    // 3: Log processor setup here

    var server = await shelf_io.serve(handler, host, port);
    server.autoCompress = true;

    log.info('serving on: $baseUrl');
  }
}
```

Then we call the start method from our `main.dart` some place between `WidgetsFlutterBinding.ensureInitialized()` and `runApp`

```dart
void main() async {
  // ...
  WidgetsFlutterBinding.ensureInitialized();
  // ...
  await LocalMockApiServer().start();

  runApp(
    //...
  );
}
```

Doing this will start the server in the background, and your app should launch as it should before. You should see the logs;

```
LocalMockApiServer: starting...
LocalMockApiServer: serving on: http://localhost:3131
```

`await`'ing on `LocalMockApiServer().start()` will ensure that server is up and running before your app starts calling the endpoints.

Implement your mock API endpoint handlers, these go where I marked `// 1` and `// 2` above;

Parsing access token from request headers, and responding it as user id (doesn't make sense but just for testing and visibility)

```dart
app.get('/user/account', (Request req) async {
  return JsonMockResponse.ok({
    'id': req.accessToken,
  });
});
```

`JsonMockResponse.ok` `Request.accessToken` are implemented as convenience extensions, I will explain them below.

Responding with an array as the root of the json;

```dart
app.get('/inventory', (Request req) async {
  return JsonMockResponse.ok([
    {
      'key': 'value',
    },
    {
      'key': 'value',
    },
  ], delay: 1200); // Maybe you need more than the default delay
});
```

If you want a post request handler swap `get` with `post` after `app.`. `bodyJsonValue` method on `Request` is implemented as an extension. Explained below after this block.

```dart
app.post('/account/create', (Request req) async {
  var token = await req.bodyJsonValue('token');
  log.info('create account request for token: $token');
  return JsonMockResponse.ok({
    'id': 'mock_id_${token?.substring(0, 8)}',
  });
});
```

Set up the log processor. This part below replaces `// 3` above inside the start method. This is for intercepting the server logs and plugging in whatever logging system you have. I'm using [logger](https://pub.dev/packages/logger).

```dart
Future<void> start() async {
  // ...

  var handler = const Pipeline().addMiddleware(
    logRequests(logger: (message, isError) {
      if (isError)
        log.severe(message);
      else
        log.info(message);
    }),
  ).addHandler(app);

  // ...
}
```

And then we have couple quality-of-life extensions on top of flutter's `Request` and `Response`. Include these after the `LocalMockApiServer` definition.

Request extension adds two things;
- `bodyJsonValue`: Reads request body then decodes it as json.
- `accessToken`: Reads standard oauth Authorization header's Bearer value.

```dart
extension on Request {
  Future<String?> bodyJsonValue(String param) async {
    return jsonDecode(await this.readAsString())?[param];
  }

  String? get accessToken =>
      this.headers['Authorization']?.split('Bearer ').last;
}
```

JsonMockResponse is an extension based on `Response` with a re-definition of `ok`. Which responds with 200 status code and encodes the given map into json string as body. Responds with a optionally configurable delay.

Since this code is likely to be repeated in every response, saves time by not writing Content-Type headers and encoding code repeatedly.

```dart
extension JsonMockResponse on Response {
  static ok<T>(T json, {int delay = 800}) async {
    await Future.delayed(Duration(milliseconds: delay)); // Emulate lag
    return Response.ok(
      jsonEncode(json),
      headers: {'Content-Type': 'application/json'},
    );
  }
}
```

This is it. Then call these endpoints as you would from any local server. As in `http://localhost:3131/inventory`. Don't forget that this server runs in the phone or emulator/simulator. Unless you are targeting desktop or web. This server won't be accessible from your desktop environment.

This solution is simply and idea, that was surprisingly easy top implement that saved a lot of time for me. I was able to implement the API Client code, data models, deserialization and serialization even before any APIs were developed. It was particulary useful as this mock server is distributed along with the app itself, from Google play internal testing or testflight etc. Keep in mind that all of these code is meant to be deleted once the actual apis exist. Let me know what you think about this idea!
